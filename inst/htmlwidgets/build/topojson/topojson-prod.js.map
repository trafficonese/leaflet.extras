{"version":3,"sources":["webpack://topojson/webpack/bootstrap","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/identity.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/transform.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/bbox.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/reverse.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/feature.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/stitch.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/mesh.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/merge.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/bisect.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/neighbors.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/untransform.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/quantize.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/hash/hashmap.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/hash/point-equal.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/hash/point-hash.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/join.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/hash/hashset.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/cut.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/geometry.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/prequantize.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/topology.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/bounds.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/dedup.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/extract.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/delta.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/prune.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/filter.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/filterAttached.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/planar.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/filterWeight.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/filterAttachedWeight.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/heap.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/presimplify.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/quantile.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/simplify.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/spherical.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","identity","x","src_transform","transform","x0","y0","kx","scale","ky","dx","translate","dy","input","j","length","output","Array","src_bbox","topology","key","t","Infinity","x1","y1","bboxPoint","bboxGeometry","type","geometries","forEach","coordinates","arcs","arc","objects","src_reverse","array","features","map","feature_feature","id","bbox","properties","geometry","feature_object","transformPoint","points","pop","a","k","push","point","line","ring","polygon","stitch","stitchedArcs","fragmentByStart","fragmentByEnd","fragments","emptyIndex","flush","f","start","end","g","e","p1","p0","dp","ends","fg","concat","unshift","gf","mesh_meshArcs","apply","this","arguments","filter","geom","geomsByArc","extract0","extract1","extract2","geoms","mesh_extractArcs","merge_mergeArcs","polygonsByArc","polygons","groups","extract","area","b","Math","abs","merge_planarRingArea","_","group","neighbors","ki","bisect","lo","hi","mid","src_neighbors","indexesByArc","geometryType","LineString","MultiLineString","Polygon","MultiPolygon","indexes","ij","ik","splice","untransform","round","quantize","Error","box","floor","inputs","outputs","quantizePoint","quantizeGeometry","hashmap","size","hash","equal","keyType","keyEmpty","valueType","keystore","max","ceil","log","LN2","valstore","mask","set","index","matchKey","collisions","maybeSet","missingValue","keys","point_equal","pointA","pointB","buffer","ArrayBuffer","floats","Float64Array","uints","Uint32Array","point_hash","join","currentIndex","nextIndex","lines","rings","indexByPoint","hashIndex","equalIndex","Int32Array","visitedByIndex","leftByIndex","rightByIndex","junctionByIndex","Int8Array","junctionCount","lineStart","lineEnd","sequence","ringStart","ringEnd","previousIndex","leftIndex","rightIndex","junctionByPoint","empty","store","add","match","has","values","hashset","cut_reverse","geomifyFeature","geomifyGeometry","src_topology","quantization","boundGeometry","boundGeometryType","GeometryCollection","Point","boundPoint","MultiPoint","boundLine","boundMultiLine","y","undefined","bounds","src_geometry","quantizePoints","pi","px","py","quantizeLine","quantizeRing","quantizePolygon","quantizeGeometryType","prequantize","arcCount","next","arcsByEnd","dedupLine","dedupRing","startPoint","endPoint","startArcs","startArc","endArcs","endArc","equalLine","reverseEqualLine","equalRing","reverseEqualRing","findMinimumOffset","arcA","arcB","ia","ib","ja","jb","ka","kb","minimum","minimumPoint","dedup","junctions","lineMid","0","1","ringMid","ringFixed","offset","cut","extractGeometry","extractGeometryType","extractLine","extractRing","extractMultiRing","src_extract","indexByArc","topology_hashArc","topology_equalArc","indexGeometry","indexGeometryType","slice","indexArcs","indexMultiArcs","delta","src_filter","oldObjects","newObjects","filterGeometry","filterRings","filter_filterIdentity","filter_filterNotNull","filterInteriorRing","filter_filterTrue","newArcs","oldArcs","oldArcsLength","oldIndex","newIndexByOldIndex","newArcsLength","newIndex","scanGeometry","scanArcs","scanMultiArcs","scanArc","reindexGeometry","reindexArcs","reindexMultiArcs","reindexArc","prune","filterAttached","ownerByArc","ownerIndex","testGeometry","testArcs","owner","planarTriangleArea","triangle","planar_planarRingArea","filterWeight","minWeight","weight","Number","MIN_VALUE","interior","src_feature","filterAttachedWeight","w","compare","presimplify_copy","presimplify","heap","up","parent","down","child","removed","remove","src_heap","triangles","maxWeight","previous","update","src_quantile","isFinite","h","quantile","sort","descending","simplify","PI","tau","quarterPi","radians","atan2","cos","sin","halfArea","closed","lambda0","cosPhi0","sinPhi0","sum","lambda1","phi1","cosPhi1","sinPhi1","dLambda","sdLambda","adLambda","u","v","sphericalRingArea","sphericalTriangleArea"],"mappings":"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","file":"topojson-prod.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default function(x) {\n  return x;\n}\n","import identity from \"./identity\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","import transform from \"./transform\";\n\nexport default function(topology) {\n  var t = transform(topology.transform), key,\n      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n  function bboxPoint(p) {\n    p = t(p);\n    if (p[0] < x0) x0 = p[0];\n    if (p[0] > x1) x1 = p[0];\n    if (p[1] < y0) y0 = p[1];\n    if (p[1] > y1) y1 = p[1];\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  topology.arcs.forEach(function(arc) {\n    var i = -1, n = arc.length, p;\n    while (++i < n) {\n      p = t(arc[i], i);\n      if (p[0] < x0) x0 = p[0];\n      if (p[0] > x1) x1 = p[0];\n      if (p[1] < y0) y0 = p[1];\n      if (p[1] > y1) y1 = p[1];\n    }\n  });\n\n  for (key in topology.objects) {\n    bboxGeometry(topology.objects[key]);\n  }\n\n  return [x0, y0, x1, y1];\n}\n","export default function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n","import reverse from \"./reverse\";\nimport transform from \"./transform\";\n\nexport default function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature(topology, o); })}\n      : feature(topology, o);\n}\n\nexport function feature(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nexport function object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n","export default function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n}\n","import {object} from \"./feature\";\nimport stitch from \"./stitch\";\n\nexport default function(topology) {\n  return object(topology, meshArcs.apply(this, arguments));\n}\n\nexport function meshArcs(topology, object, filter) {\n  var arcs, i, n;\n  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);\n  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n}\n\nfunction extractArcs(topology, object, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\n  return arcs;\n}\n","import {object} from \"./feature\";\nimport stitch from \"./stitch\";\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nexport default function(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n}\n\nexport function mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    })\n  };\n}\n","export default function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}\n","import bisect from \"./bisect\";\n\nexport default function(objects) {\n  var indexesByArc = {}, // arc index -> array of object indexes\n      neighbors = objects.map(function() { return []; });\n\n  function line(arcs, i) {\n    arcs.forEach(function(a) {\n      if (a < 0) a = ~a;\n      var o = indexesByArc[a];\n      if (o) o.push(i);\n      else indexesByArc[a] = [i];\n    });\n  }\n\n  function polygon(arcs, i) {\n    arcs.forEach(function(arc) { line(arc, i); });\n  }\n\n  function geometry(o, i) {\n    if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n  }\n\n  var geometryType = {\n    LineString: line,\n    MultiLineString: polygon,\n    Polygon: polygon,\n    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n  };\n\n  objects.forEach(geometry);\n\n  for (var i in indexesByArc) {\n    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n      for (var k = j + 1; k < m; ++k) {\n        var ij = indexes[j], ik = indexes[k], n;\n        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n      }\n    }\n  }\n\n  return neighbors;\n}\n","import identity from \"./identity\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2,\n        n = input.length,\n        output = new Array(n),\n        x1 = Math.round((input[0] - dx) / kx),\n        y1 = Math.round((input[1] - dy) / ky);\n    output[0] = x1 - x0, x0 = x1;\n    output[1] = y1 - y0, y0 = y1;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","import bbox from \"./bbox\";\nimport untransform from \"./untransform\";\n\nexport default function(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be 2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}\n","export default function(size, hash, equal, keyType, keyEmpty, valueType) {\n  if (arguments.length === 3) {\n    keyType = valueType = Array;\n    keyEmpty = null;\n  }\n\n  var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n      valstore = new valueType(size),\n      mask = size - 1;\n\n  for (var i = 0; i < size; ++i) {\n    keystore[i] = keyEmpty;\n  }\n\n  function set(key, value) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index] = value;\n      if (++collisions >= size) throw new Error(\"full hashmap\");\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    keystore[index] = key;\n    valstore[index] = value;\n    return value;\n  }\n\n  function maybeSet(key, value) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index];\n      if (++collisions >= size) throw new Error(\"full hashmap\");\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    keystore[index] = key;\n    valstore[index] = value;\n    return value;\n  }\n\n  function get(key, missingValue) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index];\n      if (++collisions >= size) break;\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    return missingValue;\n  }\n\n  function keys() {\n    var keys = [];\n    for (var i = 0, n = keystore.length; i < n; ++i) {\n      var matchKey = keystore[i];\n      if (matchKey != keyEmpty) keys.push(matchKey);\n    }\n    return keys;\n  }\n\n  return {\n    set: set,\n    maybeSet: maybeSet, // set if unset\n    get: get,\n    keys: keys\n  };\n}\n","export default function(pointA, pointB) {\n  return pointA[0] === pointB[0] && pointA[1] === pointB[1];\n}\n","// TODO if quantized, use simpler Int32 hashing?\n\nvar buffer = new ArrayBuffer(16),\n    floats = new Float64Array(buffer),\n    uints = new Uint32Array(buffer);\n\nexport default function(point) {\n  floats[0] = point[0];\n  floats[1] = point[1];\n  var hash = uints[0] ^ uints[1];\n  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];\n  return hash & 0x7fffffff;\n}\n","import hashset from \"./hash/hashset\";\nimport hashmap from \"./hash/hashmap\";\nimport equalPoint from \"./hash/point-equal\";\nimport hashPoint from \"./hash/point-hash\";\n\n// Given an extracted (pre-)topology, identifies all of the junctions. These are\n// the points at which arcs (lines or rings) will need to be cut so that each\n// arc is represented uniquely.\n//\n// A junction is a point where at least one arc deviates from another arc going\n// through the same point. For example, consider the point B. If there is a arc\n// through ABC and another arc through CBA, then B is not a junction because in\n// both cases the adjacent point pairs are {A,C}. However, if there is an\n// additional arc ABD, then {A,D} != {A,C}, and thus B becomes a junction.\n//\n// For a closed ring ABCA, the first point As adjacent points are the second\n// and last point {B,C}. For a line, the first and last point are always\n// considered junctions, even if the line is closed; this ensures that a closed\n// line is never rotated.\nexport default function(topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      indexes = index(),\n      visitedByIndex = new Int32Array(coordinates.length),\n      leftByIndex = new Int32Array(coordinates.length),\n      rightByIndex = new Int32Array(coordinates.length),\n      junctionByIndex = new Int8Array(coordinates.length),\n      junctionCount = 0, // upper bound on number of junctions\n      i, n,\n      previousIndex,\n      currentIndex,\n      nextIndex;\n\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;\n  }\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineStart = line[0],\n        lineEnd = line[1];\n    currentIndex = indexes[lineStart];\n    nextIndex = indexes[++lineStart];\n    ++junctionCount, junctionByIndex[currentIndex] = 1; // start\n    while (++lineStart <= lineEnd) {\n      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);\n    }\n    ++junctionCount, junctionByIndex[nextIndex] = 1; // end\n  }\n\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    visitedByIndex[i] = -1;\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0] + 1,\n        ringEnd = ring[1];\n    previousIndex = indexes[ringEnd - 1];\n    currentIndex = indexes[ringStart - 1];\n    nextIndex = indexes[ringStart];\n    sequence(i, previousIndex, currentIndex, nextIndex);\n    while (++ringStart <= ringEnd) {\n      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);\n    }\n  }\n\n  function sequence(i, previousIndex, currentIndex, nextIndex) {\n    if (visitedByIndex[currentIndex] === i) return; // ignore self-intersection\n    visitedByIndex[currentIndex] = i;\n    var leftIndex = leftByIndex[currentIndex];\n    if (leftIndex >= 0) {\n      var rightIndex = rightByIndex[currentIndex];\n      if ((leftIndex !== previousIndex || rightIndex !== nextIndex)\n        && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {\n        ++junctionCount, junctionByIndex[currentIndex] = 1;\n      }\n    } else {\n      leftByIndex[currentIndex] = previousIndex;\n      rightByIndex[currentIndex] = nextIndex;\n    }\n  }\n\n  function index() {\n    var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),\n        indexes = new Int32Array(coordinates.length);\n\n    for (var i = 0, n = coordinates.length; i < n; ++i) {\n      indexes[i] = indexByPoint.maybeSet(i, i);\n    }\n\n    return indexes;\n  }\n\n  function hashIndex(i) {\n    return hashPoint(coordinates[i]);\n  }\n\n  function equalIndex(i, j) {\n    return equalPoint(coordinates[i], coordinates[j]);\n  }\n\n  visitedByIndex = leftByIndex = rightByIndex = null;\n\n  var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint), j;\n\n  // Convert back to a standard hashset by point for caller convenience.\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    if (junctionByIndex[j = indexes[i]]) {\n      junctionByPoint.add(coordinates[j]);\n    }\n  }\n\n  return junctionByPoint;\n}\n","export default function(size, hash, equal, type, empty) {\n  if (arguments.length === 3) {\n    type = Array;\n    empty = null;\n  }\n\n  var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n      mask = size - 1;\n\n  for (var i = 0; i < size; ++i) {\n    store[i] = empty;\n  }\n\n  function add(value) {\n    var index = hash(value) & mask,\n        match = store[index],\n        collisions = 0;\n    while (match != empty) {\n      if (equal(match, value)) return true;\n      if (++collisions >= size) throw new Error(\"full hashset\");\n      match = store[index = (index + 1) & mask];\n    }\n    store[index] = value;\n    return true;\n  }\n\n  function has(value) {\n    var index = hash(value) & mask,\n        match = store[index],\n        collisions = 0;\n    while (match != empty) {\n      if (equal(match, value)) return true;\n      if (++collisions >= size) break;\n      match = store[index = (index + 1) & mask];\n    }\n    return false;\n  }\n\n  function values() {\n    var values = [];\n    for (var i = 0, n = store.length; i < n; ++i) {\n      var match = store[i];\n      if (match != empty) values.push(match);\n    }\n    return values;\n  }\n\n  return {\n    add: add,\n    has: has,\n    values: values\n  };\n}\n","import join from \"./join\";\n\n// Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared\n// point sequences are identified. The topology can then be subsequently deduped\n// to remove exact duplicate arcs.\nexport default function(topology) {\n  var junctions = join(topology),\n      coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      next,\n      i, n;\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineMid = line[0],\n        lineEnd = line[1];\n    while (++lineMid < lineEnd) {\n      if (junctions.has(coordinates[lineMid])) {\n        next = {0: lineMid, 1: line[1]};\n        line[1] = lineMid;\n        line = line.next = next;\n      }\n    }\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0],\n        ringMid = ringStart,\n        ringEnd = ring[1],\n        ringFixed = junctions.has(coordinates[ringStart]);\n    while (++ringMid < ringEnd) {\n      if (junctions.has(coordinates[ringMid])) {\n        if (ringFixed) {\n          next = {0: ringMid, 1: ring[1]};\n          ring[1] = ringMid;\n          ring = ring.next = next;\n        } else { // For the first junction, we can rotate rather than cut.\n          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);\n          coordinates[ringEnd] = coordinates[ringStart];\n          ringFixed = true;\n          ringMid = ringStart; // restart; we may have skipped junctions\n        }\n      }\n    }\n  }\n\n  return topology;\n}\n\nfunction rotateArray(array, start, end, offset) {\n  reverse(array, start, end);\n  reverse(array, start, start + offset);\n  reverse(array, start + offset, end);\n}\n\nfunction reverse(array, start, end) {\n  for (var mid = start + ((end-- - start) >> 1), t; start < mid; ++start, --end) {\n    t = array[start], array[start] = array[end], array[end] = t;\n  }\n}\n","// Given a hash of GeoJSON objects, returns a hash of GeoJSON geometry objects.\n// Any null input geometry objects are represented as {type: null} in the output.\n// Any feature.{id,properties,bbox} are transferred to the output geometry object.\n// Each output geometry object is a shallow copy of the input (e.g., properties, coordinates)!\nexport default function(inputs) {\n  var outputs = {}, key;\n  for (key in inputs) outputs[key] = geomifyObject(inputs[key]);\n  return outputs;\n}\n\nfunction geomifyObject(input) {\n  return input == null ? {type: null}\n      : (input.type === \"FeatureCollection\" ? geomifyFeatureCollection\n      : input.type === \"Feature\" ? geomifyFeature\n      : geomifyGeometry)(input);\n}\n\nfunction geomifyFeatureCollection(input) {\n  var output = {type: \"GeometryCollection\", geometries: input.features.map(geomifyFeature)};\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n\nfunction geomifyFeature(input) {\n  var output = geomifyGeometry(input.geometry), key; // eslint-disable-line no-unused-vars\n  if (input.id != null) output.id = input.id;\n  if (input.bbox != null) output.bbox = input.bbox;\n  for (key in input.properties) { output.properties = input.properties; break; }\n  return output;\n}\n\nfunction geomifyGeometry(input) {\n  if (input == null) return {type: null};\n  var output = input.type === \"GeometryCollection\" ? {type: \"GeometryCollection\", geometries: input.geometries.map(geomifyGeometry)}\n      : input.type === \"Point\" || input.type === \"MultiPoint\" ? {type: input.type, coordinates: input.coordinates}\n      : {type: input.type, arcs: input.coordinates}; // TODO Check for unknown types?\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n","export default function(objects, bbox, n) {\n  var x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3],\n      kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n      ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n\n  function quantizePoint(input) {\n    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n  }\n\n  function quantizePoints(input, m) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n), // pessimistic\n        pi,\n        px,\n        py,\n        x,\n        y;\n\n    while (++i < n) {\n      pi = input[i];\n      x = Math.round((pi[0] - x0) * kx);\n      y = Math.round((pi[1] - y0) * ky);\n      if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points\n    }\n\n    output.length = j;\n    while (j < m) j = output.push([output[0][0], output[0][1]]);\n    return output;\n  }\n\n  function quantizeLine(input) {\n    return quantizePoints(input, 2);\n  }\n\n  function quantizeRing(input) {\n    return quantizePoints(input, 4);\n  }\n\n  function quantizePolygon(input) {\n    return input.map(quantizeRing);\n  }\n\n  function quantizeGeometry(o) {\n    if (o != null && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);\n  }\n\n  var quantizeGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(quantizeGeometry); },\n    Point: function(o) { o.coordinates = quantizePoint(o.coordinates); },\n    MultiPoint: function(o) { o.coordinates = o.coordinates.map(quantizePoint); },\n    LineString: function(o) { o.arcs = quantizeLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(quantizeLine); },\n    Polygon: function(o) { o.arcs = quantizePolygon(o.arcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(quantizePolygon); }\n  };\n\n  for (var key in objects) {\n    quantizeGeometry(objects[key]);\n  }\n\n  return {\n    scale: [1 / kx, 1 / ky],\n    translate: [x0, y0]\n  };\n}\n","import bounds from \"./bounds\";\nimport cut from \"./cut\";\nimport dedup from \"./dedup\";\nimport delta from \"./delta\";\nimport extract from \"./extract\";\nimport geometry from \"./geometry\";\nimport hashmap from \"./hash/hashmap\";\nimport prequantize from \"./prequantize\";\n\n// Constructs the TopoJSON Topology for the specified hash of features.\n// Each object in the specified hash must be a GeoJSON object,\n// meaning FeatureCollection, a Feature or a geometry object.\nexport default function(objects, quantization) {\n  var bbox = bounds(objects = geometry(objects)),\n      transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n      topology = dedup(cut(extract(objects))),\n      coordinates = topology.coordinates,\n      indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n\n  objects = topology.objects; // for garbage collection\n  topology.bbox = bbox;\n  topology.arcs = topology.arcs.map(function(arc, i) {\n    indexByArc.set(arc, i);\n    return coordinates.slice(arc[0], arc[1] + 1);\n  });\n\n  delete topology.coordinates;\n  coordinates = null;\n\n  function indexGeometry(geometry) {\n    if (geometry && indexGeometryType.hasOwnProperty(geometry.type)) indexGeometryType[geometry.type](geometry);\n  }\n\n  var indexGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(indexGeometry); },\n    LineString: function(o) { o.arcs = indexArcs(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    Polygon: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(indexMultiArcs); }\n  };\n\n  function indexArcs(arc) {\n    var indexes = [];\n    do {\n      var index = indexByArc.get(arc);\n      indexes.push(arc[0] < arc[1] ? index : ~index);\n    } while (arc = arc.next);\n    return indexes;\n  }\n\n  function indexMultiArcs(arcs) {\n    return arcs.map(indexArcs);\n  }\n\n  for (var key in objects) {\n    indexGeometry(objects[key]);\n  }\n\n  if (transform) {\n    topology.transform = transform;\n    topology.arcs = delta(topology.arcs);\n  }\n\n  return topology;\n}\n\nfunction hashArc(arc) {\n  var i = arc[0], j = arc[1], t;\n  if (j < i) t = i, i = j, j = t;\n  return i + 31 * j;\n}\n\nfunction equalArc(arcA, arcB) {\n  var ia = arcA[0], ja = arcA[1],\n      ib = arcB[0], jb = arcB[1], t;\n  if (ja < ia) t = ia, ia = ja, ja = t;\n  if (jb < ib) t = ib, ib = jb, jb = t;\n  return ia === ib && ja === jb;\n}\n","// Computes the bounding box of the specified hash of GeoJSON objects.\nexport default function(objects) {\n  var x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity;\n\n  function boundGeometry(geometry) {\n    if (geometry != null && boundGeometryType.hasOwnProperty(geometry.type)) boundGeometryType[geometry.type](geometry);\n  }\n\n  var boundGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(boundGeometry); },\n    Point: function(o) { boundPoint(o.coordinates); },\n    MultiPoint: function(o) { o.coordinates.forEach(boundPoint); },\n    LineString: function(o) { boundLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs.forEach(boundLine); },\n    Polygon: function(o) { o.arcs.forEach(boundLine); },\n    MultiPolygon: function(o) { o.arcs.forEach(boundMultiLine); }\n  };\n\n  function boundPoint(coordinates) {\n    var x = coordinates[0],\n        y = coordinates[1];\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  }\n\n  function boundLine(coordinates) {\n    coordinates.forEach(boundPoint);\n  }\n\n  function boundMultiLine(coordinates) {\n    coordinates.forEach(boundLine);\n  }\n\n  for (var key in objects) {\n    boundGeometry(objects[key]);\n  }\n\n  return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;\n}\n","import hashmap from \"./hash/hashmap\";\nimport equalPoint from \"./hash/point-equal\";\nimport hashPoint from \"./hash/point-hash\";\n\n// Given a cut topology, combines duplicate arcs.\nexport default function(topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines, line,\n      rings = topology.rings, ring,\n      arcCount = lines.length + rings.length,\n      i, n;\n\n  delete topology.lines;\n  delete topology.rings;\n\n  // Count the number of (non-unique) arcs to initialize the hashmap safely.\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i]; while (line = line.next) ++arcCount;\n  }\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i]; while (ring = ring.next) ++arcCount;\n  }\n\n  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n      arcs = topology.arcs = [];\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n    do {\n      dedupLine(line);\n    } while (line = line.next);\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n    if (ring.next) { // arc is no longer closed\n      do {\n        dedupLine(ring);\n      } while (ring = ring.next);\n    } else {\n      dedupRing(ring);\n    }\n  }\n\n  function dedupLine(arc) {\n    var startPoint,\n        endPoint,\n        startArcs, startArc,\n        endArcs, endArc,\n        i, n;\n\n    // Does this arc match an existing arc in order?\n    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n      for (i = 0, n = startArcs.length; i < n; ++i) {\n        startArc = startArcs[i];\n        if (equalLine(startArc, arc)) {\n          arc[0] = startArc[0];\n          arc[1] = startArc[1];\n          return;\n        }\n      }\n    }\n\n    // Does this arc match an existing arc in reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (reverseEqualLine(endArc, arc)) {\n          arc[1] = endArc[0];\n          arc[0] = endArc[1];\n          return;\n        }\n      }\n    }\n\n    if (startArcs) startArcs.push(arc); else arcsByEnd.set(startPoint, [arc]);\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function dedupRing(arc) {\n    var endPoint,\n        endArcs,\n        endArc,\n        i, n;\n\n    // Does this arc match an existing line in order, or reverse order?\n    // Rings are closed, so their start point and end point is the same.\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    // Otherwise, does this arc match an existing ring in order, or reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function equalLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n    return true;\n  }\n\n  function reverseEqualLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n    return true;\n  }\n\n  function equalRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  function reverseEqualRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = n - findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  // Rings are rotated to a consistent, but arbitrary, start point.\n  // This is necessary to detect when a ring and a rotated copy are dupes.\n  function findMinimumOffset(arc) {\n    var start = arc[0],\n        end = arc[1],\n        mid = start,\n        minimum = mid,\n        minimumPoint = coordinates[mid];\n    while (++mid < end) {\n      var point = coordinates[mid];\n      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n        minimum = mid;\n        minimumPoint = point;\n      }\n    }\n    return minimum - start;\n  }\n\n  return topology;\n}\n","// Extracts the lines and rings from the specified hash of geometry objects.\n//\n// Returns an object with three properties:\n//\n// * coordinates - shared buffer of [x, y] coordinates\n// * lines - lines extracted from the hash, of the form [start, end]\n// * rings - rings extracted from the hash, of the form [start, end]\n//\n// For each ring or line, start and end represent inclusive indexes into the\n// coordinates buffer. For rings (and closed lines), coordinates[start] equals\n// coordinates[end].\n//\n// For each line or polygon geometry in the input hash, including nested\n// geometries as in geometry collections, the `coordinates` array is replaced\n// with an equivalent `arcs` array that, for each line (for line string\n// geometries) or ring (for polygon geometries), points to one of the above\n// lines or rings.\nexport default function(objects) {\n  var index = -1,\n      lines = [],\n      rings = [],\n      coordinates = [];\n\n  function extractGeometry(geometry) {\n    if (geometry && extractGeometryType.hasOwnProperty(geometry.type)) extractGeometryType[geometry.type](geometry);\n  }\n\n  var extractGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(extractGeometry); },\n    LineString: function(o) { o.arcs = extractLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(extractLine); },\n    Polygon: function(o) { o.arcs = o.arcs.map(extractRing); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(extractMultiRing); }\n  };\n\n  function extractLine(line) {\n    for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];\n    var arc = {0: index - n + 1, 1: index};\n    lines.push(arc);\n    return arc;\n  }\n\n  function extractRing(ring) {\n    for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];\n    var arc = {0: index - n + 1, 1: index};\n    rings.push(arc);\n    return arc;\n  }\n\n  function extractMultiRing(rings) {\n    return rings.map(extractRing);\n  }\n\n  for (var key in objects) {\n    extractGeometry(objects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    coordinates: coordinates,\n    lines: lines,\n    rings: rings,\n    objects: objects\n  };\n}\n","// Given an array of arcs in absolute (but already quantized!) coordinates,\n// converts to fixed-point delta encoding.\n// This is a destructive operation that modifies the given arcs!\nexport default function(arcs) {\n  var i = -1,\n      n = arcs.length;\n\n  while (++i < n) {\n    var arc = arcs[i],\n        j = 0,\n        k = 1,\n        m = arc.length,\n        point = arc[0],\n        x0 = point[0],\n        y0 = point[1],\n        x1,\n        y1;\n\n    while (++j < m) {\n      point = arc[j], x1 = point[0], y1 = point[1];\n      if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;\n    }\n\n    if (k === 1) arc[k++] = [0, 0]; // Each arc must be an array of two or more positions.\n\n    arc.length = k;\n  }\n\n  return arcs;\n}\n","export default function(topology) {\n  var oldObjects = topology.objects,\n      newObjects = {},\n      oldArcs = topology.arcs,\n      oldArcsLength = oldArcs.length,\n      oldIndex = -1,\n      newIndexByOldIndex = new Array(oldArcsLength),\n      newArcsLength = 0,\n      newArcs,\n      newIndex = -1,\n      key;\n\n  function scanGeometry(input) {\n    switch (input.type) {\n      case \"GeometryCollection\": input.geometries.forEach(scanGeometry); break;\n      case \"LineString\": scanArcs(input.arcs); break;\n      case \"MultiLineString\": input.arcs.forEach(scanArcs); break;\n      case \"Polygon\": input.arcs.forEach(scanArcs); break;\n      case \"MultiPolygon\": input.arcs.forEach(scanMultiArcs); break;\n    }\n  }\n\n  function scanArc(index) {\n    if (index < 0) index = ~index;\n    if (!newIndexByOldIndex[index]) newIndexByOldIndex[index] = 1, ++newArcsLength;\n  }\n\n  function scanArcs(arcs) {\n    arcs.forEach(scanArc);\n  }\n\n  function scanMultiArcs(arcs) {\n    arcs.forEach(scanArcs);\n  }\n\n  function reindexGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(reindexGeometry)}; break;\n      case \"LineString\": output = {type: \"LineString\", arcs: reindexArcs(input.arcs)}; break;\n      case \"MultiLineString\": output = {type: \"MultiLineString\", arcs: input.arcs.map(reindexArcs)}; break;\n      case \"Polygon\": output = {type: \"Polygon\", arcs: input.arcs.map(reindexArcs)}; break;\n      case \"MultiPolygon\": output = {type: \"MultiPolygon\", arcs: input.arcs.map(reindexMultiArcs)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function reindexArc(oldIndex) {\n    return oldIndex < 0 ? ~newIndexByOldIndex[~oldIndex] : newIndexByOldIndex[oldIndex];\n  }\n\n  function reindexArcs(arcs) {\n    return arcs.map(reindexArc);\n  }\n\n  function reindexMultiArcs(arcs) {\n    return arcs.map(reindexArcs);\n  }\n\n  for (key in oldObjects) {\n    scanGeometry(oldObjects[key]);\n  }\n\n  newArcs = new Array(newArcsLength);\n\n  while (++oldIndex < oldArcsLength) {\n    if (newIndexByOldIndex[oldIndex]) {\n      newIndexByOldIndex[oldIndex] = ++newIndex;\n      newArcs[newIndex] = oldArcs[oldIndex];\n    }\n  }\n\n  for (key in oldObjects) {\n    newObjects[key] = reindexGeometry(oldObjects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: newArcs\n  };\n}\n","import prune from \"./prune\";\n\nexport default function(topology, filter) {\n  var oldObjects = topology.objects,\n      newObjects = {},\n      key;\n\n  if (filter == null) filter = filterTrue;\n\n  function filterGeometry(input) {\n    var output, arcs;\n    switch (input.type) {\n      case \"Polygon\": {\n        arcs = filterRings(input.arcs);\n        output = arcs ? {type: \"Polygon\", arcs: arcs} : {type: null};\n        break;\n      }\n      case \"MultiPolygon\": {\n        arcs = input.arcs.map(filterRings).filter(filterIdentity);\n        output = arcs.length ? {type: \"MultiPolygon\", arcs: arcs} : {type: null};\n        break;\n      }\n      case \"GeometryCollection\": {\n        arcs = input.geometries.map(filterGeometry).filter(filterNotNull);\n        output = arcs.length ? {type: \"GeometryCollection\", geometries: arcs} : {type: null};\n        break;\n      }\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function filterRings(arcs) {\n    return arcs.length && filterExteriorRing(arcs[0]) // if the exterior is small, ignore any holes\n        ? [arcs[0]].concat(arcs.slice(1).filter(filterInteriorRing))\n        : null;\n  }\n\n  function filterExteriorRing(ring) {\n    return filter(ring, false);\n  }\n\n  function filterInteriorRing(ring) {\n    return filter(ring, true);\n  }\n\n  for (key in oldObjects) {\n    newObjects[key] = filterGeometry(oldObjects[key]);\n  }\n\n  return prune({\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: topology.arcs\n  });\n}\n\nfunction filterTrue() {\n  return true;\n}\n\nfunction filterIdentity(x) {\n  return x;\n}\n\nfunction filterNotNull(geometry) {\n  return geometry.type != null;\n}\n","export default function(topology) {\n  var ownerByArc = new Array(topology.arcs.length), // arc index -> index of unique associated ring, or -1 if used by multiple rings\n      ownerIndex = 0,\n      key;\n\n  function testGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(testGeometry); break;\n      case \"Polygon\": testArcs(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(testArcs); break;\n    }\n  }\n\n  function testArcs(arcs) {\n    for (var i = 0, n = arcs.length; i < n; ++i, ++ownerIndex) {\n      for (var ring = arcs[i], j = 0, m = ring.length; j < m; ++j) {\n        var arc = ring[j];\n        if (arc < 0) arc = ~arc;\n        var owner = ownerByArc[arc];\n        if (owner == null) ownerByArc[arc] = ownerIndex;\n        else if (owner !== ownerIndex) ownerByArc[arc] = -1;\n      }\n    }\n  }\n\n  for (key in topology.objects) {\n    testGeometry(topology.objects[key]);\n  }\n\n  return function(ring) {\n    for (var j = 0, m = ring.length, arc; j < m; ++j) {\n      if (ownerByArc[(arc = ring[j]) < 0 ? ~arc : arc] === -1) {\n        return true;\n      }\n    }\n    return false;\n  };\n}\n","export function planarTriangleArea(triangle) {\n  var a = triangle[0], b = triangle[1], c = triangle[2];\n  return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1])) / 2;\n}\n\nexport function planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area) / 2;\n}\n","import {feature} from \"topojson-client\";\nimport {planarRingArea} from \"./planar\";\n\nexport default function(topology, minWeight, weight) {\n  minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight;\n\n  if (weight == null) weight = planarRingArea;\n\n  return function(ring, interior) {\n    return weight(feature(topology, {type: \"Polygon\", arcs: [ring]}).geometry.coordinates[0], interior) >= minWeight;\n  };\n}\n","import filterAttached from \"./filterAttached\";\nimport filterWeight from \"./filterWeight\";\n\nexport default function(topology, minWeight, weight) {\n  var a = filterAttached(topology),\n      w = filterWeight(topology, minWeight, weight);\n  return function(ring, interior) {\n    return a(ring, interior) || w(ring, interior);\n  };\n}\n","function compare(a, b) {\n  return a[1][2] - b[1][2];\n}\n\nexport default function() {\n  var heap = {},\n      array = [],\n      size = 0;\n\n  heap.push = function(object) {\n    up(array[object._ = size] = object, size++);\n    return size;\n  };\n\n  heap.pop = function() {\n    if (size <= 0) return;\n    var removed = array[0], object;\n    if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);\n    return removed;\n  };\n\n  heap.remove = function(removed) {\n    var i = removed._, object;\n    if (array[i] !== removed) return; // invalid request\n    if (i !== --size) object = array[size], (compare(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);\n    return i;\n  };\n\n  function up(object, i) {\n    while (i > 0) {\n      var j = ((i + 1) >> 1) - 1,\n          parent = array[j];\n      if (compare(object, parent) >= 0) break;\n      array[parent._ = i] = parent;\n      array[object._ = i = j] = object;\n    }\n  }\n\n  function down(object, i) {\n    while (true) {\n      var r = (i + 1) << 1,\n          l = r - 1,\n          j = i,\n          child = array[j];\n      if (l < size && compare(array[l], child) < 0) child = array[j = l];\n      if (r < size && compare(array[r], child) < 0) child = array[j = r];\n      if (j === i) break;\n      array[child._ = i] = child;\n      array[object._ = i = j] = object;\n    }\n  }\n\n  return heap;\n}\n","import {transform} from \"topojson-client\";\nimport newHeap from \"./heap\";\nimport {planarTriangleArea} from \"./planar\";\n\nfunction copy(point) {\n  return [point[0], point[1], 0];\n}\n\nexport default function(topology, weight) {\n  var point = topology.transform ? transform(topology.transform) : copy,\n      heap = newHeap();\n\n  if (weight == null) weight = planarTriangleArea;\n\n  var arcs = topology.arcs.map(function(arc) {\n    var triangles = [],\n        maxWeight = 0,\n        triangle,\n        i,\n        n;\n\n    arc = arc.map(point);\n\n    for (i = 1, n = arc.length - 1; i < n; ++i) {\n      triangle = [arc[i - 1], arc[i], arc[i + 1]];\n      triangle[1][2] = weight(triangle);\n      triangles.push(triangle);\n      heap.push(triangle);\n    }\n\n    // Always keep the arc endpoints!\n    arc[0][2] = arc[n][2] = Infinity;\n\n    for (i = 0, n = triangles.length; i < n; ++i) {\n      triangle = triangles[i];\n      triangle.previous = triangles[i - 1];\n      triangle.next = triangles[i + 1];\n    }\n\n    while (triangle = heap.pop()) {\n      var previous = triangle.previous,\n          next = triangle.next;\n\n      // If the weight of the current point is less than that of the previous\n      // point to be eliminated, use the latters weight instead. This ensures\n      // that the current point cannot be eliminated without eliminating\n      // previously- eliminated points.\n      if (triangle[1][2] < maxWeight) triangle[1][2] = maxWeight;\n      else maxWeight = triangle[1][2];\n\n      if (previous) {\n        previous.next = next;\n        previous[2] = triangle[2];\n        update(previous);\n      }\n\n      if (next) {\n        next.previous = previous;\n        next[0] = triangle[0];\n        update(next);\n      }\n    }\n\n    return arc;\n  });\n\n  function update(triangle) {\n    heap.remove(triangle);\n    triangle[1][2] = weight(triangle);\n    heap.push(triangle);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    objects: topology.objects,\n    arcs: arcs\n  };\n}\n","export default function(topology, p) {\n  var array = [];\n\n  topology.arcs.forEach(function(arc) {\n    arc.forEach(function(point) {\n      if (isFinite(point[2])) { // Ignore endpoints, whose weight is Infinity.\n        array.push(point[2]);\n      }\n    });\n  });\n\n  return array.length && quantile(array.sort(descending), p);\n}\n\nfunction quantile(array, p) {\n  if (!(n = array.length)) return;\n  if ((p = +p) <= 0 || n < 2) return array[0];\n  if (p >= 1) return array[n - 1];\n  var n,\n      h = (n - 1) * p,\n      i = Math.floor(h),\n      a = array[i],\n      b = array[i + 1];\n  return a + (b - a) * (h - i);\n}\n\nfunction descending(a, b) {\n  return b - a;\n}\n","export default function(topology, minWeight) {\n  minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight;\n\n  // Remove points whose weight is less than the minimum weight.\n  var arcs = topology.arcs.map(function(input) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n), // pessimistic\n        point;\n\n    while (++i < n) {\n      if ((point = input[i])[2] >= minWeight) {\n        output[j++] = [point[0], point[1]];\n      }\n    }\n\n    output.length = j;\n    return output;\n  });\n\n  return {\n    type: \"Topology\",\n    transform: topology.transform,\n    bbox: topology.bbox,\n    objects: topology.objects,\n    arcs: arcs\n  };\n}\n","var pi = Math.PI,\n    tau = 2 * pi,\n    quarterPi = pi / 4,\n    radians = pi / 180,\n    abs = Math.abs,\n    atan2 = Math.atan2,\n    cos = Math.cos,\n    sin = Math.sin;\n\nfunction halfArea(ring, closed) {\n  var i = 0,\n      n = ring.length,\n      sum = 0,\n      point = ring[closed ? i++ : n - 1],\n      lambda0, lambda1 = point[0] * radians,\n      phi1 = (point[1] * radians) / 2 + quarterPi,\n      cosPhi0, cosPhi1 = cos(phi1),\n      sinPhi0, sinPhi1 = sin(phi1);\n\n  for (; i < n; ++i) {\n    point = ring[i];\n    lambda0 = lambda1, lambda1 = point[0] * radians;\n    phi1 = (point[1] * radians) / 2 + quarterPi;\n    cosPhi0 = cosPhi1, cosPhi1 = cos(phi1);\n    sinPhi0 = sinPhi1, sinPhi1 = sin(phi1);\n\n    // Spherical excess E for a spherical triangle with vertices: south pole,\n    // previous point, current point.  Uses a formula derived from Cagnolis\n    // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n    // See https://github.com/d3/d3-geo/blob/master/README.md#geoArea\n    var dLambda = lambda1 - lambda0,\n        sdLambda = dLambda >= 0 ? 1 : -1,\n        adLambda = sdLambda * dLambda,\n        k = sinPhi0 * sinPhi1,\n        u = cosPhi0 * cosPhi1 + k * cos(adLambda),\n        v = k * sdLambda * sin(adLambda);\n    sum += atan2(v, u);\n  }\n\n  return sum;\n}\n\nexport function sphericalRingArea(ring, interior) {\n  var sum = halfArea(ring, true);\n  if (interior) sum *= -1;\n  return (sum < 0 ? tau + sum : sum) * 2;\n}\n\nexport function sphericalTriangleArea(t) {\n  return abs(halfArea(t, false)) * 2;\n}\n"],"sourceRoot":""}